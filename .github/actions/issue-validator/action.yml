name: 'Issue Validator'
description: 'Analyzes GitHub issues for completeness, ensuring all required information is provided for effective triage'
author: 'HPCC4J Team'

inputs:
  github-token:
    description: 'GitHub token for API access'
    required: true
  issue-number:
    description: 'Issue number to analyze'
    required: true
  is-revalidation:
    description: 'Whether this is a re-validation (true) or initial validation (false)'
    required: false
    default: 'false'

runs:
  using: composite
  steps:
    - name: Analyze Issue Content
      uses: actions/github-script@v7
      with:
        github-token: ${{ inputs.github-token }}
        script: |
          const isRevalidation = '${{ inputs.is-revalidation }}' === 'true';
          
          // Get the issue details
          const { data: issue } = await github.rest.issues.get({
            owner: context.repo.owner,
            repo: context.repo.repo,
            issue_number: parseInt('${{ inputs.issue-number }}')
          });
          
          const issueBody = issue.body || '';
          const issueTitle = issue.title || '';
          const issueLabels = issue.labels.map(label => label.name);
          
          // Determine issue type from labels or title
          const isBugReport = issueLabels.includes('bug') || issueTitle.toLowerCase().includes('[bug]');
          const isFeatureRequest = issueLabels.includes('enhancement') || issueTitle.toLowerCase().includes('[feature]');
          const isQuestion = issueLabels.includes('question') || issueTitle.toLowerCase().includes('[question]');
          
          // Define required sections based on issue type
          let requiredSections = [];
          
          if (isBugReport) {
            // Bug report sections (from bug_report.yml template)
            requiredSections = [
              { name: 'Description', keywords: ['### description', 'description:', '## description'], required: true },
              { name: 'Steps to Reproduce', keywords: ['### steps to reproduce', 'steps to reproduce:', '## steps'], required: true },
              { name: 'Expected Behavior', keywords: ['### expected behavior', 'expected behavior:', '## expected'], required: true },
              { name: 'Actual Behavior', keywords: ['### actual behavior', 'actual behavior:', '## actual'], required: true },
              { name: 'HPCC Systems Version', keywords: ['### hpcc systems version', 'hpcc systems version:', 'hpcc version:'], required: true },
              { name: 'HPCC4J Module', keywords: ['### hpcc4j module', 'hpcc4j module:', '## hpcc4j module'], required: true },
              { name: 'HPCC4J Version', keywords: ['### hpcc4j version', 'hpcc4j version:'], required: true },
              { name: 'Java Version', keywords: ['### java version', 'java version:'], required: true },
              { name: 'Environment/Configuration', keywords: ['### environment/configuration', 'environment:', 'configuration:'], required: true }
            ];
          } else if (isFeatureRequest) {
            // Feature request sections (from feature_request.yml template)
            requiredSections = [
              { name: 'Feature Description', keywords: ['### feature description', 'feature description:', '## feature'], required: true },
              { name: 'Problem Statement', keywords: ['### problem statement', 'problem statement:', '## problem'], required: true },
              { name: 'Proposed Solution', keywords: ['### proposed solution', 'proposed solution:', '## solution'], required: true },
              { name: 'Affected Module(s)', keywords: ['### affected module', 'affected module:', '## module'], required: true }
            ];
          } else if (isQuestion) {
            // Question sections (from question.yml template) - simplified
            requiredSections = [
              { name: 'Question', keywords: ['### question', 'question:', '## question'], required: true }
            ];
          } else {
            // Generic validation for free-form issues (legacy or manually created)
            requiredSections = [
              { name: 'Description', keywords: ['description', 'summary', 'problem', 'issue'], required: true },
              { name: 'Context/Details', keywords: ['context', 'details', 'information', 'background'], required: true }
            ];
          }
          
          // Analyze the issue content
          const missingInfo = [];
          const presentInfo = [];
          
          for (const section of requiredSections) {
            const hasSection = section.keywords.some(keyword => 
              issueBody.toLowerCase().includes(keyword.toLowerCase()) ||
              issueTitle.toLowerCase().includes(keyword.toLowerCase())
            );
            
            if (!hasSection && section.required) {
              missingInfo.push(section.name);
            } else if (hasSection) {
              presentInfo.push(section.name);
            }
          }
          
          // Check if issue body is too short (likely incomplete)
          // More lenient for questions since they're simpler
          const minLength = isQuestion ? 30 : (isBugReport ? 150 : 100);
          const isBodyTooShort = issueBody.length < minLength;
          const isComplete = missingInfo.length === 0 && !isBodyTooShort;
          
          // Prepare analysis comment
          const headerEmoji = isRevalidation ? 'üîÑ' : 'ü§ñ';
          const headerText = isRevalidation ? 'Issue Re-validation Analysis' : 'Issue Validation Analysis';
          let analysisComment = `## ${headerEmoji} ${headerText}\n\n`;
          
          if (isComplete) {
            const thankYouText = isRevalidation 
              ? 'Thank you for updating your issue with the additional details. This issue is now ready for review!'
              : 'Thank you for providing a detailed issue report!';
            
            analysisComment += isRevalidation 
              ? '‚úÖ **Great! This issue now contains all required information!**\n\n'
              : '‚úÖ **This issue appears to contain all required information!**\n\n';
            
            analysisComment += 'The following sections were identified:\n';
            presentInfo.forEach(info => {
              analysisComment += `- ‚úÖ ${info}\n`;
            });
            analysisComment += `\n${thankYouText}\n`;
          } else {
            analysisComment += isRevalidation
              ? '‚ö†Ô∏è **This issue still appears to be missing some important information.**\n\n'
              : '‚ö†Ô∏è **This issue may be missing some important information.**\n\n';
            
            if (presentInfo.length > 0) {
              analysisComment += '**Information provided:**\n';
              presentInfo.forEach(info => {
                analysisComment += `- ‚úÖ ${info}\n`;
              });
              analysisComment += '\n';
            }
            
            if (missingInfo.length > 0) {
              const missingHeader = isRevalidation ? '**Still missing:**\n' : '**Potentially missing information:**\n';
              analysisComment += missingHeader;
              missingInfo.forEach(info => {
                analysisComment += `- ‚ö†Ô∏è ${info}\n`;
              });
              analysisComment += '\n';
            }
            
            if (isBodyTooShort) {
              const shortDescText = isRevalidation 
                ? '- ‚ö†Ô∏è The issue description is still quite brief\n\n'
                : '- ‚ö†Ô∏è The issue description appears to be very brief\n\n';
              analysisComment += shortDescText;
            }
            
            // Provide context-appropriate guidance
            const checklistHeader = isRevalidation 
              ? '### üìã Reminder: Required Information\n\n'
              : '### üìã Required Information\n\n';
            
            analysisComment += checklistHeader;
            
            if (isBugReport) {
              // Bug report specific guidance
              analysisComment += 'For bug reports, please ensure you have:\n\n';
              analysisComment += '1. **Description**: Clear description of the bug\n';
              analysisComment += '2. **Steps to Reproduce**: Numbered steps to reproduce\n';
              analysisComment += '   ```\n';
              analysisComment += '   1. Connect to HPCC cluster at...\n';
              analysisComment += '   2. Call method...\n';
              analysisComment += '   3. Observe error...\n';
              analysisComment += '   ```\n';
              analysisComment += '3. **Expected vs Actual Behavior**: What should happen vs what actually happens\n';
              analysisComment += '4. **Environment Details**:\n';
              analysisComment += '   - HPCC Systems version (e.g., 9.6.0)\n';
              analysisComment += '   - HPCC4J module and version (e.g., wsclient 9.6.2)\n';
              analysisComment += '   - Java version (e.g., Java 11)\n';
              analysisComment += '   - Configuration (ESP endpoint, authentication, etc.)\n';
              analysisComment += '5. **Code Sample**: Minimal reproducible code snippet\n';
              analysisComment += '6. **Error Details**: Full error messages and stack traces\n\n';
              analysisComment += 'üí° **Tip**: Check the [Common Issues and Solutions wiki](https://github.com/hpcc-systems/hpcc4j/wiki/Common-Issues-and-Solutions) first!\n\n';
            } else if (isFeatureRequest) {
              // Feature request specific guidance
              analysisComment += 'For feature requests, please include:\n\n';
              analysisComment += '1. **Feature Description**: What you want to add/change\n';
              analysisComment += '2. **Problem Statement**: What problem does this solve?\n';
              analysisComment += '3. **Proposed Solution**: How should it work?\n';
              analysisComment += '4. **Affected Module(s)**: Which HPCC4J modules would be affected\n';
              analysisComment += '5. **Example Usage**: Show how you would use this feature\n';
              analysisComment += '6. **Alternatives**: Any workarounds or alternatives considered\n\n';
            } else if (isQuestion) {
              // Question specific guidance - simplified
              analysisComment += 'For questions, please include:\n\n';
              analysisComment += '1. **Your Question**: What do you want to know?\n';
              analysisComment += '2. **Context**: What are you trying to accomplish? What have you tried?\n';
              analysisComment += '3. **Code/Details** (optional): Relevant code snippets, error messages, or environment details\n\n';
              analysisComment += 'üí° **Tip**: Check the [Common Issues wiki](https://github.com/hpcc-systems/hpcc4j/wiki/Common-Issues-and-Solutions) - your answer might already be there!\n\n';
            } else {
              // Generic guidance
              analysisComment += 'Please provide:\n\n';
              analysisComment += '1. **Clear Description**: What is this issue about?\n';
              analysisComment += '2. **Context**: Background information and details\n';
              analysisComment += '3. **Environment** (if applicable): Versions and configuration\n';
              analysisComment += '4. **Examples**: Code snippets or use cases\n\n';
            }
            
            analysisComment += '---\n\n';
            
            const footerText = isRevalidation
              ? '*Automatic re-validation triggered by issue update.*\n'
              : '*This analysis was performed automatically. Please update your issue with any missing information.*\n';
            analysisComment += footerText;
          }
          
          // Find existing validation comment to update instead of creating a new one
          const comments = await github.rest.issues.listComments({
            owner: context.repo.owner,
            repo: context.repo.repo,
            issue_number: issue.number
          });
          
          // Look for an existing validation comment from this bot
          const botComment = comments.data.find(comment => 
            comment.user.type === 'Bot' && 
            (comment.body.includes('Issue Validation Analysis') || comment.body.includes('Issue Re-validation Analysis'))
          );
          
          if (botComment) {
            // Update existing comment
            await github.rest.issues.updateComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              comment_id: botComment.id,
              body: analysisComment
            });
            console.log('‚úÖ Updated existing validation comment');
          } else {
            // Create new comment if none exists
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: issue.number,
              body: analysisComment
            });
            console.log('‚úÖ Created new validation comment');
          }
          
          // Manage labels based on completeness
          const hasNeedsMoreInfo = issue.labels.some(label => label.name === 'needs-more-info');
          const hasReadyForReview = issue.labels.some(label => label.name === 'ready-for-review');
          
          if (isComplete) {
            // Remove needs-more-info label if present
            if (hasNeedsMoreInfo) {
              try {
                await github.rest.issues.removeLabel({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: issue.number,
                  name: 'needs-more-info'
                });
                console.log('‚úÖ Removed needs-more-info label');
              } catch (error) {
                console.log('‚ö†Ô∏è Could not remove needs-more-info label:', error.message);
              }
            }
            
            // Ensure ready-for-review label is added
            if (!hasReadyForReview) {
              try {
                await github.rest.issues.addLabels({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: issue.number,
                  labels: ['ready-for-review']
                });
                console.log('‚úÖ Added ready-for-review label');
              } catch (error) {
                console.log('‚ö†Ô∏è Could not add ready-for-review label:', error.message);
                console.log('üí° Tip: Create the "ready-for-review" label in your repository');
              }
            }
          } else {
            // Ensure needs-more-info label is present
            if (!hasNeedsMoreInfo) {
              try {
                await github.rest.issues.addLabels({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: issue.number,
                  labels: ['needs-more-info']
                });
                console.log('‚úÖ Added needs-more-info label');
              } catch (error) {
                console.log('‚ö†Ô∏è Could not add needs-more-info label:', error.message);
                console.log('üí° Tip: Create the "needs-more-info" label in your repository');
              }
            }
            
            // Remove ready-for-review label if present
            if (hasReadyForReview) {
              try {
                await github.rest.issues.removeLabel({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: issue.number,
                  name: 'ready-for-review'
                });
                console.log('‚úÖ Removed ready-for-review label');
              } catch (error) {
                console.log('‚ö†Ô∏è Could not remove ready-for-review label:', error.message);
              }
            }
          }
          
          // Log summary
          const issueType = isBugReport ? 'Bug Report' : (isFeatureRequest ? 'Feature Request' : (isQuestion ? 'Question' : 'Generic'));
          console.log('\nüìä Analysis Summary:');
          console.log(`   Issue Type: ${issueType}`);
          console.log(`   Complete: ${isComplete ? '‚úÖ' : '‚ùå'}`);
          console.log(`   Present Info: ${presentInfo.join(', ') || 'None'}`);
          console.log(`   Missing Info: ${missingInfo.join(', ') || 'None'}`);
          console.log(`   Body Length: ${issueBody.length} characters (min: ${minLength})`);
          console.log(`   Labels: ${issueLabels.join(', ') || 'None'}`);
